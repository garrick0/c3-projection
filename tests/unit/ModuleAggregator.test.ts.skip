/**
 * ModuleAggregator Unit Tests
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { PropertyGraph, NodeType, Node } from '@garrick0/c3-parsing';
import { Logger, LogLevel } from '@garrick0/c3-shared';
import { ModuleAggregator } from '../../src/domain/services/ModuleAggregator.js';
import { AggregationLevel } from '../../src/domain/value-objects/AggregationLevel.js';

describe('ModuleAggregator', () => {
  let aggregator: ModuleAggregator;
  let logger: Logger;

  beforeEach(() => {
    logger = new Logger('test', LogLevel.ERROR);
    aggregator = new ModuleAggregator(logger);
  });

  describe('aggregate()', () => {
    it('should aggregate files by directory level', async () => {
      const graph = new PropertyGraph('test-graph');
      
      // Add file nodes
      const file1 = new Node('file-1', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/services/UserService.ts',
        domain: 'code'
      });
      const file2 = new Node('file-2', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/services/AuthService.ts',
        domain: 'code'
      });
      const file3 = new Node('file-3', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/data/DataStore.ts',
        domain: 'code'
      });

      graph.addNode(file1);
      graph.addNode(file2);
      graph.addNode(file3);

      const modules = await aggregator.aggregate(graph, '/project/src', {
        level: AggregationLevel.DIRECTORY,
        includeTests: false,
        excludePatterns: []
      });

      // Should create 2 modules: services and data
      expect(modules.length).toBe(2);

      const servicesModule = modules.find(m => m.name === 'services');
      const dataModule = modules.find(m => m.name === 'data');

      expect(servicesModule).toBeDefined();
      expect(dataModule).toBeDefined();

      expect(servicesModule!.files.length).toBe(2);
      expect(dataModule!.files.length).toBe(1);
    });

    it('should aggregate files by top-level directories', async () => {
      const graph = new PropertyGraph('test-graph');
      
      const file1 = new Node('file-1', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/domain/entities/User.ts',
        domain: 'code'
      });
      const file2 = new Node('file-2', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/domain/services/UserService.ts',
        domain: 'code'
      });
      const file3 = new Node('file-3', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/infrastructure/Database.ts',
        domain: 'code'
      });

      graph.addNode(file1);
      graph.addNode(file2);
      graph.addNode(file3);

      const modules = await aggregator.aggregate(graph, '/project/src', {
        level: AggregationLevel.TOP_LEVEL,
        includeTests: false,
        excludePatterns: []
      });

      // Should create 2 modules: domain and infrastructure
      expect(modules.length).toBe(2);

      const domainModule = modules.find(m => m.name === 'domain');
      const infraModule = modules.find(m => m.name === 'infrastructure');

      expect(domainModule).toBeDefined();
      expect(infraModule).toBeDefined();

      expect(domainModule!.files.length).toBe(2);
      expect(infraModule!.files.length).toBe(1);
    });

    it('should exclude test files when configured', async () => {
      const graph = new PropertyGraph('test-graph');
      
      const file1 = new Node('file-1', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/UserService.ts',
        domain: 'code'
      });
      const file2 = new Node('file-2', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/UserService.test.ts',
        domain: 'code'
      });

      graph.addNode(file1);
      graph.addNode(file2);

      const modules = await aggregator.aggregate(graph, '/project/src', {
        level: AggregationLevel.DIRECTORY,
        includeTests: false,
        excludePatterns: []
      });

      // Should only include non-test file
      const module = modules[0];
      expect(module.files.length).toBe(1);
      expect(module.files).toContain('file-1');
      expect(module.files).not.toContain('file-2');
    });

    it('should exclude files matching patterns', async () => {
      const graph = new PropertyGraph('test-graph');
      
      const file1 = new Node('file-1', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/index.ts',
        domain: 'code'
      });
      const file2 = new Node('file-2', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/generated/types.ts',
        domain: 'code'
      });

      graph.addNode(file1);
      graph.addNode(file2);

      const modules = await aggregator.aggregate(graph, '/project/src', {
        level: AggregationLevel.DIRECTORY,
        includeTests: false,
        excludePatterns: ['**/generated/**']
      });

      // Should exclude generated file
      const module = modules[0];
      expect(module.files).toContain('file-1');
      expect(module.files).not.toContain('file-2');
    });

    it('should calculate module metrics', async () => {
      const graph = new PropertyGraph('test-graph');
      
      const file1 = new Node('file-1', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/index.ts',
        startLine: 1,
        endLine: 100,
        domain: 'code'
      });
      const file2 = new Node('file-2', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/utils.ts',
        startLine: 1,
        endLine: 50,
        domain: 'code'
      });

      graph.addNode(file1);
      graph.addNode(file2);

      const modules = await aggregator.aggregate(graph, '/project/src', {
        level: AggregationLevel.DIRECTORY,
        includeTests: false,
        excludePatterns: []
      });

      const module = modules[0];
      expect(module.metrics.fileCount).toBe(2);
      expect(module.metrics.totalLines).toBe(149); // 100 + 50 - 1 (endLine - startLine)
    });

    it('should only aggregate code files, not filesystem nodes', async () => {
      const graph = new PropertyGraph('test-graph');
      
      // Code file from TypeScript extension
      const codeFile = new Node('file-1', NodeType.FILE, new Set(['File', 'CodeElement']), {
        filePath: '/project/src/index.ts',
        domain: 'code' // from TypeScript extension
      });
      
      // Filesystem node (should be excluded)
      const fsNode = new Node('fs-1', NodeType.FILE, new Set(['File']), {
        filePath: '/project/src/index.ts',
        domain: 'filesystem' // from Filesystem extension
      });

      graph.addNode(codeFile);
      graph.addNode(fsNode);

      const modules = await aggregator.aggregate(graph, '/project/src', {
        level: AggregationLevel.DIRECTORY,
        includeTests: false,
        excludePatterns: []
      });

      // Should only include code file, not filesystem node
      expect(modules.length).toBe(1);
      expect(modules[0].files.length).toBe(1);
      expect(modules[0].files).toContain('file-1');
      expect(modules[0].files).not.toContain('fs-1');
    });
  });
});
